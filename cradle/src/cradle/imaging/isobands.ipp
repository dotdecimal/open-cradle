#include <cradle/imaging/variant.hpp>
#include <cradle/geometry/polygonal.hpp>
#include <cradle/geometry/transformations.hpp>
#include <cradle/imaging/iterator.hpp>
#include <cradle/imaging/geometry.hpp>

namespace cradle {

namespace impl {

struct isobands_table_vertex
{
    // If this is true, this is an edge vertex, so its exact position must be
    // interpolated according to the values at the two vertices on that edge.
    // Otherwise, this is corresponds to one of the corners of the square.
    unsigned char on_edge : 1;

    // Vertices are represented as indices into the four vertices of the
    // square. Viewed with +Y down and +X to the right, the indices are
    // 0 - top left
    // 1 - top right
    // 2 - bottom right
    // 3 - bottom left

    // If on_edge is true, both indices are valid. Otherwise, only vertex0 is.
    unsigned char vertex0 : 2, vertex1 : 2;

    // If on_edge is true, this is the level at which to do the interpolation.
    // 0 corresponds to the low value. 1 is the high value.
    unsigned char interpolation_level : 1;
};

struct isobands_table_polygon
{
    unsigned char n_vertices;
    isobands_table_vertex vertices[8];
};

struct isobands_table_cell
{
    isobands_table_polygon polys[2];
};

// This is autogenerated and lives in isobands.cpp.
isobands_table_cell const*
get_isobands_table();

// The creation of isobands is generic with respect to build the resulting
// triangle list. This allows the same code to produce both colored and
// uncolored triangles.
// Whenever the algorithm generates a triangle in the isoband, it calls
// record_triangle(recorder, p0, v0, p1, v1, p2, v2).
// p0, p1, and p2 are the vertices of the triangle.
// v0, v1, and v2 are the corresponding value levels, normalized so that 0
// corresponds to the low isoband level and 1 corresponds to the high level.

static inline void
record_triangle(
    std::vector<triangle<2,double> >& tris,
    vector<2,double> const& p0, double v0,
    vector<2,double> const& p1, double v1,
    vector<2,double> const& p2, double v2)
{
    tris.push_back(triangle<2,double>(p0, p1, p2));
}

struct colored_triangle_recorder
{
    std::vector<colored_triangle<2,double> >* tris;
    rgba8 low_color, high_color;
};

static inline void
record_triangle(
    colored_triangle_recorder& recorder,
    vector<2,double> const& p0, double v0,
    vector<2,double> const& p1, double v1,
    vector<2,double> const& p2, double v2)
{
    recorder.tris->push_back(
        colored_triangle<2,double>(
            colored_vertex<2,double>(p0,
                interpolate(recorder.low_color, recorder.high_color, v0)),
            colored_vertex<2,double>(p1,
                interpolate(recorder.low_color, recorder.high_color, v1)),
            colored_vertex<2,double>(p2,
                interpolate(recorder.low_color, recorder.high_color, v2))));
}

// The positioning of isoband vertices is calculated assuming that a pixel's
// value describes the value at the center of the pixel and applying linear
// interpolation between. Along the edges, we can't interpolate, so we just
// extend the value of the edge pixels out from their centers to the actual
// edge of the image. The following functions are for generating the triangles
// to fill those areas.

// Add the two triangles to form the rectangle between the center of a corner
// pixel and the corner of the image.
// index is the index of the corner pixel.
// to_edge0 and to_edge1 are vectors from the pixel center to the edges of
// the image. Note that their order will determine the winding of the
// resulting triangles.
template<class Recorder, class Pixel, class Storage>
void add_corner_tris(
    Recorder& recorder,
    image<2,Pixel,Storage> const& img,
    double raw_low, double raw_high,
    vector2u const& index,
    vector2d const& to_edge0, vector2d const& to_edge1)
{
    double raw_value = double(get_pixel_ref(img, index));
    if (raw_value >= raw_low && raw_value < raw_high)
    {
        double v = (raw_value - raw_low) / (raw_high - raw_low);
        vector2d p = get_pixel_center(img, index);
        record_triangle(recorder,
            p, v, p + to_edge0, v, p + to_edge0 + to_edge1, v);
        record_triangle(recorder,
            p, v, p + to_edge0 + to_edge1, v, p + to_edge1, v);
    }
}

// Add the two triangles that form a quad along the edge of the image.
template<class Recorder>
void add_edge_quad(
    Recorder& recorder,
    vector2d const& p0, double v0,
    vector2d const& p1, double v1,
    vector2d const& to_edge)
{
    record_triangle(recorder, p0, v0, p0 + to_edge, v0, p1, v1);
    record_triangle(recorder, p1, v1, p0 + to_edge, v0, p1 + to_edge, v1);
}

// Add all the triangles for a single edge of the image.
template<class Recorder, class Iterator, class Step>
void add_single_edge_triangles(
    Recorder& recorder,
    std::size_t n_pixels, Iterator pixel, Step pixel_step,
    double raw_low, double raw_high,
    vector2d p, vector2d const& p_step,
    vector2d const& to_edge)
{
    double values[2];
    values[0] = double(*pixel);
    pixel += pixel_step;

    // Step along all pairs of adjacent pixels on this edge.
    for (std::size_t i = 1; i != n_pixels; ++i, p += p_step,
        pixel += pixel_step, values[0] = values[1])
    {
        values[1] = double(*pixel);

        // Calculate the points at which the gradient between the two pixels
        // intersects the low and high isoband values.
        // The points are represented as the relative distance from the first
        // pixel's center to the second (in the range of 0 to 1).
        double t_low = clamp(
            (raw_low - values[0]) / (values[1] - values[0]),
            0., 1.);
        double t_high = clamp(
            (raw_high - values[0]) / (values[1] - values[0]),
            0., 1.);

        // If this is true, then at least part of this region is within the
        // isoband.
        if (t_low != t_high)
        {
            // Sort the isoband edges spatially so that the winding order is
            // correct.
            double t0 = (std::min)(t_low, t_high);
            double t1 = (std::max)(t_low, t_high);
            // Calculate the corresponding relative values at the edges.
            double v0 =
                (interpolate(values[0], values[1], t0) - raw_low) /
                (raw_high - raw_low);
            double v1 =
                (interpolate(values[0], values[1], t1) - raw_low) /
                (raw_high - raw_low);
            // Record the quad.
            add_edge_quad(recorder, p + t0 * p_step, v0, p + t1 * p_step, v1,
                to_edge);
        }
    }
}

// Add all edge (and corner) triangles for an image isoband.
template<class Recorder, class Pixel, class Storage>
void add_edge_triangles(Recorder& recorder,
    image<2,Pixel,Storage> const& img, double low, double high)
{
    double raw_low = apply(inverse(img.value_mapping), low);
    double raw_high = apply(inverse(img.value_mapping), high);

    matrix<3,3,double> spatial_mapping = get_spatial_mapping(img);
    vector2d x_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(1, 0));
    vector2d y_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(0, 1));

    // top edge
    impl::add_single_edge_triangles(recorder, img.size[0],
        get_pixel_iterator(img, make_vector<unsigned>(0, 0)),
        img.step[0], raw_low, raw_high,
        get_pixel_center(img, make_vector<unsigned>(0, 0)),
        x_vector, -y_vector * 0.5);
    // bottom edge
    impl::add_single_edge_triangles(recorder, img.size[0],
        get_pixel_iterator(
            img, make_vector<unsigned>(img.size[0] - 1, img.size[1] - 1)),
        -img.step[0], raw_low, raw_high,
        get_pixel_center(
            img, make_vector<unsigned>(img.size[0] - 1, img.size[1] - 1)),
        -x_vector, y_vector * 0.5);
    // left edge
    impl::add_single_edge_triangles(recorder, img.size[1],
        get_pixel_iterator(img, make_vector<unsigned>(0, img.size[1] - 1)),
        -img.step[1], raw_low, raw_high,
        get_pixel_center(img, make_vector<unsigned>(0, img.size[1] - 1)),
        -y_vector, -x_vector * 0.5);
    // right edge
    impl::add_single_edge_triangles(recorder, img.size[1],
        get_pixel_iterator(
            img, make_vector<unsigned>(img.size[0] - 1, 0)),
        img.step[1], raw_low, raw_high,
        get_pixel_center(
            img, make_vector<unsigned>(img.size[0] - 1, 0)),
        y_vector, x_vector * 0.5);

    // four corners
    impl::add_corner_tris(recorder, img, raw_low, raw_high,
        make_vector<unsigned>(0, 0),
        -x_vector * 0.5, -y_vector * 0.5);
    impl::add_corner_tris(recorder, img, raw_low, raw_high,
        make_vector<unsigned>(img.size[0] - 1, 0),
        -y_vector * 0.5, x_vector * 0.5);
    impl::add_corner_tris(recorder, img, raw_low, raw_high,
        img.size - make_vector<unsigned>(1, 1),
        x_vector * 0.5, y_vector * 0.5);
    impl::add_corner_tris(recorder, img, raw_low, raw_high,
        make_vector<unsigned>(0, img.size[1] - 1),
        y_vector * 0.5, -x_vector * 0.5);
}

// Add all the triangles for an image isoband.
template<class Recorder, class Pixel, class Storage>
void add_isoband_triangles(Recorder& recorder,
    image<2,Pixel,Storage> const& img, double low, double high)
{
    if (product(img.size) == 0)
        return;

    double raw_low = apply(inverse(img.value_mapping), low);
    double raw_high = apply(inverse(img.value_mapping), high);

    double raw_denominator = 1 / (raw_high - raw_low);

    matrix<3,3,double> spatial_mapping = get_spatial_mapping(img);
    vector2d x_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(1, 0));
    vector2d y_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(0, 1));

    impl::isobands_table_cell const* isobands_table =
        impl::get_isobands_table();

    for (unsigned i = 0; i != img.size[1] - 1; ++i)
    {
        span_iterator<2,Pixel,Storage> j0 = get_row_begin(img, i);
        span_iterator<2,Pixel,Storage> j0_end = get_row_end(img, i);
        span_iterator<2,Pixel,Storage> j1 = get_row_begin(img, i + 1);

        vector2d locations[4];
        locations[0] = get_pixel_center(img, make_vector<unsigned>(0, i));
        locations[1] = locations[0] + x_vector;
        locations[2] = locations[1] + y_vector;
        locations[3] = locations[0] + y_vector;

        double values[5];
        values[0] = (double(*j0) - raw_low) * raw_denominator;
        values[3] = (double(*j1) - raw_low) * raw_denominator;
        ++j0;
        ++j1;

        for (; j0 != j0_end; ++j0, ++j1)
        {
            values[1] = (double(*j0) - raw_low) * raw_denominator;
            values[2] = (double(*j1) - raw_low) * raw_denominator;

            values[4] = (values[0] + values[1] + values[2] + values[3]) / 4;

            int table_index = 0;
            for (int k = 4; k >= 0; --k)
            {
                table_index *= 3;
                table_index += values[k] < 0 ? 0 : (values[k] < 1 ? 1 : 2);
            }

            impl::isobands_table_cell const& cell =
                isobands_table[table_index];

            // There are up to two polygons per cell.
            for (int k = 0; k != 2; ++k)
            {
                impl::isobands_table_polygon const& poly = cell.polys[k];

                if (poly.n_vertices == 0)
                    break;
                assert(poly.n_vertices >= 3);

                // Decode the vertices and calculate their actual positions in
                // space.
                vector2d vertices[8];
                double vertex_values[8];
                for (unsigned char l = 0; l != poly.n_vertices; ++l)
                {
                    impl::isobands_table_vertex const& v = poly.vertices[l];
                    if (v.on_edge)
                    {
                        double fraction =
                            (v.interpolation_level - values[v.vertex0]) /
                            (values[v.vertex1] - values[v.vertex0]);
                        vertices[l] =
                            locations[v.vertex0] +
                            (locations[v.vertex1] - locations[v.vertex0]) *
                            fraction;
                        vertex_values[l] = v.interpolation_level;
                    }
                    else
                    {
                        vertices[l] = locations[v.vertex0];
                        vertex_values[l] = values[v.vertex0];
                    }
                }

                // Triangulate.
                int n_tris = poly.n_vertices - 2;
                for (int i = 0; i != n_tris; ++i)
                {
                    record_triangle(recorder,
                        vertices[0], vertex_values[0],
                        vertices[i + 1], vertex_values[i + 1],
                        vertices[i + 2], vertex_values[i + 2]);
                }
            }

            // Set up for next iteration.

            values[0] = values[1];
            values[3] = values[2];

            for (int k = 0; k < 4; ++k)
                locations[k] += x_vector;
        }
    }

    impl::add_edge_triangles(recorder, img, low, high);
}

// variant version
template<class Recorder>
struct add_isoband_triangles_fn
{
    Recorder* recorder;
    double low, high;
    template<class Pixel, class Storage>
    void operator()(image<2,Pixel,Storage> const& img)
    { add_isoband_triangles(*recorder, img, low, high); }
};
template<class Recorder, class Storage>
void add_isoband_triangles(Recorder& recorder,
    image<2,variant,Storage> const& img, double low, double high)
{
    add_isoband_triangles_fn<Recorder> fn;
    fn.recorder = &recorder;
    fn.low = low;
    fn.high = high;
    apply_fn_to_gray_variant(fn, img);
}

}

template<class Pixel, class Storage>
std::vector<triangle<2,double> >
compute_isobands(image<2,Pixel,Storage> const& img, double low, double high)
{
    std::vector<triangle<2,double> > tris;
    impl::add_isoband_triangles(tris, img, low, high);
    return tris;
}

template<class Pixel, class Storage>
std::vector<colored_triangle<2,double> >
compute_shaded_isobands(image<2,Pixel,Storage> const& img,
    rgba8 const& low_color, double low_level,
    rgba8 const& high_color, double high_level)
{
    std::vector<colored_triangle<2,double> > tris;
    impl::colored_triangle_recorder recorder;
    recorder.tris = &tris;
    recorder.low_color = low_color;
    recorder.high_color = high_color;
    impl::add_isoband_triangles(recorder, img, low_level, high_level);
    return tris;
}

}
