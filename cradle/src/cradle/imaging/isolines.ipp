#include <cradle/imaging/geometry.hpp>
#include <cradle/imaging/variant.hpp>
#include <cradle/imaging/iterator.hpp>

namespace cradle {

namespace impl {

struct isolines_table_vertex
{
    unsigned char vertex0 : 2, vertex1 : 2;
};

struct isolines_table_line
{
    isolines_table_vertex vertices[2];
};

struct isolines_table_cell
{
    unsigned char n_lines;
    isolines_table_line lines[2];
};

// This is autogenerated and lives in isolines.cpp.
isolines_table_cell const*
get_isolines_table();

template<class Iterator, class Step>
void add_single_edge_connection_lines(
    std::vector<line_segment<2,double> >& lines,
    std::size_t n_pixels,
    Iterator pixel, Step pixel_step, double raw_level,
    vector2d p, vector2d const& p_step,
    vector2d const& to_outer_edge)
{
    double values[2];
    values[0] = double(*pixel);
    pixel += pixel_step;

    for (std::size_t i = 1; i != n_pixels; ++i, p += p_step,
        pixel += pixel_step)
    {
        values[1] = double(*pixel);

        double t = (raw_level - values[0]) /
            (values[1] - values[0]);
        if (t >= 0 && t < 1)
        {
            vector2d intersection = p + p_step * t;
            lines.push_back(line_segment<2,double>(
                intersection + to_outer_edge, intersection));
        }

        values[0] = values[1];
    }
}

template<class Pixel, class Storage>
void add_edge_connection_lines(
    std::vector<line_segment<2,double> >& lines,
    image<2,Pixel,Storage> const& img, double level)
{
    double raw_level = apply(inverse(img.value_mapping), level);

    matrix<3,3,double> spatial_mapping = get_spatial_mapping(img);
    vector2d x_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(1, 0));
    vector2d y_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(0, 1));

    // top edge
    impl::add_single_edge_connection_lines(lines, img.size[0],
        get_pixel_iterator(img, make_vector<unsigned>(0, 0)),
        img.step[0], raw_level,
        get_pixel_center(img, make_vector<unsigned>(0, 0)),
        x_vector, -y_vector * 0.5);
    // bottom edge
    impl::add_single_edge_connection_lines(lines, img.size[0],
        get_pixel_iterator(
            img, make_vector<unsigned>(0, img.size[1] - 1)),
        img.step[0], raw_level,
        get_pixel_center(
            img, make_vector<unsigned>(0, img.size[1] - 1)),
        x_vector, y_vector * 0.5);
    // left edge
    impl::add_single_edge_connection_lines(lines, img.size[1],
        get_pixel_iterator(img, make_vector<unsigned>(0, 0)),
        img.step[1], raw_level,
        get_pixel_center(img, make_vector<unsigned>(0, 0)),
        y_vector, -x_vector * 0.5);
    // right edge
    impl::add_single_edge_connection_lines(lines, img.size[1],
        get_pixel_iterator(
            img, make_vector<unsigned>(img.size[0] - 1, 0)),
        img.step[1], raw_level,
        get_pixel_center(
            img, make_vector<unsigned>(img.size[0] - 1, 0)),
        y_vector, x_vector * 0.5);
}

} // namespace impl

template<class Pixel, class Storage>
std::vector<line_segment<2,double> >
compute_isolines(image<2,Pixel,Storage> const& img, double level)
{
    std::vector<line_segment<2,double> > lines;

    if (product(img.size) == 0)
        return lines;

    double raw_level = apply(inverse(img.value_mapping), level);

    matrix<3,3,double> spatial_mapping = get_spatial_mapping(img);
    vector2d x_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(1, 0));
    vector2d y_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(0, 1));

    impl::isolines_table_cell const* isolines_table =
        impl::get_isolines_table();

    for (unsigned i = 0; i != img.size[1] - 1; ++i)
    {
        span_iterator<2,Pixel,Storage> j0 = get_row_begin(img, i);
        span_iterator<2,Pixel,Storage> j0_end = get_row_end(img, i);
        span_iterator<2,Pixel,Storage> j1 = get_row_begin(img, i + 1);

        vector2d locations[4];
        locations[0] = get_pixel_center(img,
            make_vector<unsigned>(0, i));
        locations[1] = locations[0] + x_vector;
        locations[2] = locations[1] + y_vector;
        locations[3] = locations[0] + y_vector;

        double values[5];
        values[0] = double(*j0);
        values[3] = double(*j1);
        ++j0;
        ++j1;

        for (; j0 != j0_end; ++j0, ++j1)
        {
            values[1] = double(*j0);
            values[2] = double(*j1);

            values[4] = (values[0] + values[1] + values[2] + values[3]) / 4;

            int table_index = 0;
            for (int k = 0; k != 5; ++k)
                table_index += (values[k] < raw_level ? 0 : 1) << k;

            impl::isolines_table_cell const& cell =
                isolines_table[table_index];
            for (int k = 0; k != cell.n_lines; ++k)
            {
                impl::isolines_table_line const& line = cell.lines[k];

                // Decode the vertices and calculate their actual positions in
                // space.
                vector2d vertices[2];
                for (unsigned char l = 0; l != 2; ++l)
                {
                    impl::isolines_table_vertex const& v = line.vertices[l];
                    double fraction = (raw_level - values[v.vertex0]) /
                        (values[v.vertex1] - values[v.vertex0]);
                    vertices[l] =
                        locations[v.vertex0] +
                        (locations[v.vertex1] - locations[v.vertex0]) *
                        fraction;
                }

                // Add the segment.
                lines.push_back(line_segment<2,double>(
                    vertices[0], vertices[1]));
            }

            // Set up for next iteration.

            values[0] = values[1];
            values[3] = values[2];

            for (int k = 0; k < 4; ++k)
                locations[k] += x_vector;
        }
    }

    impl::add_edge_connection_lines(lines, img, level);

    return lines;
}

namespace impl {
    struct compute_isolines_fn
    {
        std::vector<line_segment<2,double> > result;
        double level;
        template<class Pixel, class Storage>
        void operator()(image<2,Pixel,Storage> const& img)
        { result = compute_isolines(img, level); }
    };
}

template<class Storage>
std::vector<line_segment<2,double> >
compute_isolines(image<2,variant,Storage> const& img, double level)
{
    impl::compute_isolines_fn fn;
    fn.level = level;
    apply_fn_to_gray_variant(fn, img);
    return fn.result;
}

namespace impl {

template<class Pixel, class Step>
void close_edge(
    std::vector<line_segment<2,double> >& lines,
    std::size_t n_pixels, Pixel pixel, Step pixel_step, double raw_level,
    vector2d p, vector2d const& p_step)
{
    double values[2];
    values[0] = double(*pixel);
    pixel += pixel_step;

    for (std::size_t i = 1; i != n_pixels; ++i, p += p_step,
        pixel += pixel_step)
    {
        values[1] = double(*pixel);

        if (values[0] >= raw_level)
        {
            if (values[1] >= raw_level)
            {
                lines.push_back(line_segment<2,double>(
                    p, p + p_step));
            }
            else
            {
                double f = (raw_level - values[0]) /
                    (values[1] - values[0]);
                vector2d intersection = p + p_step * f;
                lines.push_back(line_segment<2,double>(
                    p, intersection));
            }
        }
        else if (values[1] >= raw_level)
        {
            double f = (raw_level - values[0]) /
                (values[1] - values[0]);
            vector2d intersection = p + p_step * f;
            lines.push_back(line_segment<2,double>(
                p + p_step, intersection));
        }

        values[0] = values[1];
    }
}

template<class Pixel, class Storage>
void close_corner(
    std::vector<line_segment<2,double> >& lines,
    image<2,Pixel,Storage> const& img, double raw_level,
    vector2u const& index, vector2d const& x_vector,
    vector2d const& y_vector)
{
    if (get_pixel_ref(img, index) >= raw_level)
    {
        vector2d p = get_pixel_center(img, index);
        lines.push_back(line_segment<2,double>(
            p + x_vector, p + x_vector + y_vector));
        lines.push_back(line_segment<2,double>(
            p + y_vector, p + x_vector + y_vector));
    }
}

} // namespace impl

template<class Pixel, class Storage>
void close_isoline_contours(
    std::vector<line_segment<2,double> >& lines,
    image<2,Pixel,Storage> const& img, double level)
{
    if (product(img.size) == 0)
        return;

    double raw_level = apply(inverse(img.value_mapping), level);

    matrix<3,3,double> spatial_mapping = get_spatial_mapping(img);
    vector2d x_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(1, 0));
    vector2d y_vector =
        transform_vector(spatial_mapping,
            make_vector<double>(0, 1));

    // top edge
    impl::close_edge(lines, img.size[0],
        get_pixel_iterator(img, make_vector<unsigned>(0, 0)),
        img.step[0], raw_level,
        get_pixel_center(img, make_vector<unsigned>(0, 0))
            - y_vector * 0.5,
        x_vector);
    // bottom edge
    impl::close_edge(lines, img.size[0],
        get_pixel_iterator(
            img, make_vector<unsigned>(0, img.size[1] - 1)),
        img.step[0], raw_level,
        get_pixel_center(
            img, make_vector<unsigned>(0, img.size[1] - 1))
            + y_vector * 0.5,
        x_vector);
    // left edge
    impl::close_edge(lines, img.size[1],
        get_pixel_iterator(img, make_vector<unsigned>(0, 0)),
        img.step[1], raw_level,
        get_pixel_center(img, make_vector<unsigned>(0, 0))
            - x_vector * 0.5,
        y_vector);
    // right edge
    impl::close_edge(lines, img.size[1],
        get_pixel_iterator(
            img, make_vector<unsigned>(img.size[0] - 1, 0)),
        img.step[1], raw_level,
        get_pixel_center(
            img, make_vector<unsigned>(img.size[0] - 1, 0))
            + x_vector * 0.5,
        y_vector);

    // four corners
    impl::close_corner(lines, img, raw_level,
        make_vector<unsigned>(0, 0),
        -x_vector * 0.5, -y_vector * 0.5);
    impl::close_corner(lines, img, raw_level,
        make_vector<unsigned>(img.size[0] - 1, 0),
        x_vector * 0.5, -y_vector * 0.5);
    impl::close_corner(lines, img, raw_level,
        img.size - make_vector<unsigned>(1, 1),
        x_vector * 0.5, y_vector * 0.5);
    impl::close_corner(lines, img, raw_level,
        make_vector<unsigned>(0, img.size[1] - 1),
        -x_vector * 0.5, y_vector * 0.5);
}

namespace impl {
    struct close_isoline_contours_fn
    {
        std::vector<line_segment<2,double> >* lines;
        double level;
        template<class Pixel, class Storage>
        void operator()(image<2,Pixel,Storage> const& img)
        { close_isoline_contours(*lines, img, level); }
    };
}

template<class Storage>
void close_isoline_contours(
    std::vector<line_segment<2,double> >& lines,
    image<2,variant,Storage> const& img, double level)
{
    impl::close_isoline_contours_fn fn;
    fn.lines = &lines;
    fn.level = level;
    apply_fn_to_gray_variant(fn, img);
}

}
